<!DOCTYPE html>
<html>
<head>
	<title></title>
	<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.js"></script>
	<script src="OrbitControls.js"></script>
	<script>
		var R = 100.0
		var camera, scene, renderer, container, lights, globeMesh;

		function toRadians(d) {
			return d * Math.PI / 180.0;
		}

		/* Convert the vertex locations in lat/lon and radius to Cartesian coordinates
		 */
		function getVertexPositions(cellData, R) {
			return $.map(cellData.vertices, function(v) {
				var R_elev = R;
				// if (cellData.atts.hasOwnProperty('STD_ELEV')) 
				// 	R_elev = R * (1 + .00001 * cellData.atts.STD_ELEV);
				// else
				// 	R_elev = R;
				return [[1 * R_elev * Math.cos(toRadians(v[1])) * Math.cos(toRadians(v[0])),
								 1 * R_elev * Math.sin(toRadians(v[1])),
								 1 * R_elev * Math.cos(toRadians(v[1])) * Math.sin(toRadians(v[0]))
								 ]]
			})
		}

		function createCellGeometry(geo, cell, R, vi) {
			var vp = getVertexPositions(cell, R);
			// console.log(vp);
			var color = 0x0000f0;
			geo.vertices.push(
				new THREE.Vector3(vp[0][0], vp[0][1], vp[0][2]),
				new THREE.Vector3(vp[1][0], vp[1][1], vp[1][2]),
				new THREE.Vector3(vp[2][0], vp[2][1], vp[2][2]),
				new THREE.Vector3(vp[3][0], vp[3][1], vp[3][2]),
				new THREE.Vector3(vp[4][0], vp[4][1], vp[4][2]),
				new THREE.Vector3(vp[5][0], vp[5][1], vp[5][2])
			);
			faces = [
				new THREE.Face3(0+vi, 1+vi, 2+vi),
				new THREE.Face3(3+vi, 4+vi, 5+vi),
				new THREE.Face3(0+vi, 2+vi, 3+vi),
				new THREE.Face3(0+vi, 3+vi, 5+vi)
			];
			// faces = [
			// 	new THREE.Face3(2+vi, 1+vi, 0+vi),
			// 	new THREE.Face3(5+vi, 4+vi, 3+vi),
			// 	new THREE.Face3(3+vi, 2+vi, 0+vi),
			// 	new THREE.Face3(5+vi, 3+vi, 0+vi)
			// ];

			if (false && cell.atts.PCT_URBAN > 2.5)
				$.each(faces, function(i, face) { face.color.setRGB( .6, .6, .2); });
			else if (cell.hasOwnProperty('location_name') && cell.location_name != null)
				$.each(faces, function(i, face) { face.color.setRGB( .2, .2, .2); });
			else if (cell.atts.PCT_LAKE > 5)
				$.each(faces, function(i, face) { face.color.setRGB( 0, .4, .6); });
			else if (cell.atts.PCT_GLACIER > 5)
				$.each(faces, function(i, face) { face.color.setRGB( .8, .8, .9); });
			// else if (cell.atts.SOIL_COLOR < 10)
			// 	$.each(faces, function(i, face) { face.color.setRGB( .85, .75, .5); });
			else if (cell.atts.LANDFRAC_PFT > .6)
				$.each(faces, function(i, face) { face.color.setRGB( .2, .35, .2); });
			else
				$.each(faces, function(i, face) { face.color.setRGB( .1, .1, .8); });
			
			$.each(faces, function(i, face) { geo.faces.push(face); });
			return;
		}

		function init(json) {
			console.log('init');
			container = document.getElementById( 'container' );
			camera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 1, 3500 );
			camera.position.z = 1000;
			camera.lookAt(0, 0, 0);
			scene = new THREE.Scene();

			var ambientLight = new THREE.AmbientLight( 0x444444 );
			scene.add( ambientLight );

			lights = [];
			lights[ 0 ] = new THREE.PointLight( 0xffffff, .6, 0 );
			lights[ 1 ] = new THREE.PointLight( 0xffffff, .6, 0 );
			lights[ 2 ] = new THREE.PointLight( 0xffffff, .6, 0 );

			lights[ 0 ].position.set( 0, 400, 0 );
			lights[ 1 ].position.set( -700, 0, 1000 );
			lights[ 2 ].position.set( - 200, - 400, - 200 );

			// scene.add( lights[ 0 ] );
			scene.add( lights[ 1 ] );
			// scene.add( lights[ 2 ] );

			var geo = new THREE.Geometry();
			var vi = 0;
			$.each(json, function(i) {
				var cell = json[i];
				createCellGeometry(geo, cell, R, vi);
				vi = vi + 6
			});
			geo.computeBoundingSphere();
			geo.computeFaceNormals();
			geo.computeVertexNormals();
			var material = new THREE.MeshPhongMaterial( 
				{
					wireframe: false, 
					color: 0xffffff, 
					emissive: 0x222222,
					metalness: 0.5,
					shading: THREE.FlatShading,
					vertexColors: THREE.FaceColors,
					side: THREE.DoubleSide,
					// roughne
				} 
			);
			globeMesh = new THREE.Mesh(geo, material);
			// globeMesh.rotation.x = -Math.PI / 2;

			scene.add(globeMesh);

			renderer = new THREE.WebGLRenderer( { antialias: false } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );
			window.addEventListener( 'resize', onWindowResize, false );

			controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.enableDamping = true;
			controls.dampingFactor = 0.25;
			controls.enableZoom = true;
			console.log("done init");
			animate();
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {
			requestAnimationFrame( animate );
			renderer.render( scene, camera );
			globeMesh.rotation.y += 0.001;
		}
	
		window.onload = function() {
			console.log('loading data');
			$.getJSON("geodesic_data.json", function(json) {
				init(json);
			});
		}
	</script>
</head>
<body>
		<div id="container"></div>

</body>
</html>